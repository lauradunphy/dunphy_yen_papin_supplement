if (length(ret) == 0) return(NULL)
return(ret[[1]])
}
.section.value <- function(seclist, heading) {
sec <- .section.by.heading(seclist, heading)
if (length(sec) == 0) return(NA)
return( sec[[1]]$Information[[1]]$NumValue )
}
.section.handler <- function(sec, keep = NULL, ignore = NULL) {
n <- sec$TOCHeading
if (!is.null(ignore) && n %in% ignore) return(NULL)
if (!is.null(keep) && !(n %in% keep)) return(NULL)
ret <- lapply(sec$Information, function(info) {
info.name <- info$Name
if (info.name == n) info.name <- ''
val <- NA
if ("NumValue" %in% names(info)) val <- as.numeric(info$NumValue)
else if ("StringValue" %in% names(info)) val <- info$StringValue
else if ("BinaryValue" %in% names(info)) val <- info$BinaryValue
ret <- data.frame(val=val)
if (info.name != '') {
names(ret) <- sprintf("%s.%s", n, info.name)
} else {
names(ret) <- n
}
return(ret)
})
return(ret)
}
.inchikey.2.cid <- function(key) {
url <- sprintf("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/inchikey/%s/cids/JSON", key)
page <- .read.url(url)
if (is.null(page)) return(NULL)
record <- fromJSON(content=page)
}
.cmpd.id2id <- function(id, src.type, dest.type, quiet=TRUE) {
entity <- switch(src.type,
inchikey = 'compound',
cid = 'compound',
name = 'compound',
inchi = 'compound',
sid = 'substance',
aid = 'assay')
if (is.null(entity)) {
warning("Invalid src.type specified")
return(NULL)
}
if (!(dest.type %in% c('sids', 'cids', 'aids'))) {
warning("Invalid dest.type specified")
return(NULL)
}
url <- sprintf("https://pubchem.ncbi.nlm.nih.gov/rest/pug/%s/%s/%s/%s/JSON",
entity, src.type, id, dest.type)
if (!quiet)
cat(url, '\n')
page <- .read.url(url)
if (is.null(page)) return(NULL)
record <- fromJSON(content=page)
if ('Fault' %in% names(record)) return(NULL)
else if ('IdentifierList' %in% names(record)) {
return(record$IdentifierList$CID[1])
} else if ('InformationList' %in% names(record)) {
info <- record$InformationList$Information[[1]]
if (dest.type == 'sids') ret <- info$SID
else if (dest.type == 'aids') ret <- info$AID
else if (dest.type == 'cids') ret <- info$CID
return(ret)
} else {
warning(sprintf("Unhandled response. Field names are: %s", paste0(names(record))))
return(NULL)
}
}
get.cid2 <- function(cid, quiet=TRUE) {
url <- sprintf('https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/data/compound/%d/JSON', cid)
page <- .read.url(url)
if (is.null(page)) {
warning(sprintf("No data found for %d", cid))
return(NULL)
}
record <- fromJSON(content=page)$Record
sections <- record$Section
## Identifiers
ids <- .section.by.heading(sections, "Names and Identifiers")
ids <- .section.by.heading(ids$Section, "Computed Descriptors")
ivals <- lapply(ids$Section, .section.handler)
ivals <- do.call(cbind, unlist(Filter(function(x) !is.null(x), ivals), recursive=FALSE))
## Process chemprops
props <- .section.by.heading(sections, "Chemical and Physical Properties")
if (is.null(props)) {
warning(sprintf("No phys/chem properties section for %d", cid))
return(NULL)
}
computed <- .section.by.heading(props$Section, "Computed Properties")
# cvals <- lapply(computed$Section, .section.handler,
#                 ignore= c(##"CACTVS Substructure Key Fingerprint",
#                   "Compound Is Canonicalized",
#                   "Covalently-Bonded Unit Count"))
# cvals <- do.call(cbind, unlist(Filter(function(x) !is.null(x), cvals), recursive=FALSE))
experimental <- .section.by.heading(props$Section, "Experimental Properties")
if (is.null(experimental)) {
evals <- data.frame(pKa=NA,"Kovats Retention Index"=NA)
} else {
evals <- lapply(experimental$Section, .section.handler,
keep = c('pKa', "Kovats Retention Index"))
evals <- unlist(Filter(function(x) !is.null(x), evals), recursive=FALSE)
if (is.null(evals))
evals <- data.frame(pKa=NA, "Kovats Retention Index"=NA)
else
evals <- do.call(cbind, evals)
}
return(data.frame(CID=cid, ivals, evals))
}
cids <- c(5282108, 5282148, 91754124)
dat <- lapply(cids, get.cid2)
install.packages('jsonlite')
install.packages("jsonlite")
library(jsonlite)
install.packages("jsonlite")
library(jsonlite)
library(rlang)
library(rpubchem)
library(dplyr)
library(RCurl)
library(stringr)
library(jsonlite)
.get.pug.url <- function() {
return("http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi")
}
.load.pug.query <- function(query.filename) {
path <- system.file('pugxml', query.filename, package='rpubchem')
doc <- xmlParse(path)
return(doc)
}
.xml2pugq <- function(xml) {
s <- saveXML(xml)
s <- gsub('<\\?xml version="1\\.0"\\?>', '', s)
s <- gsub("\\n", "", s)
return(s)
}
.get.poll.xml <- function(reqid) {
d <- .load.pug.query("pug-poll.xml")
n <- getNodeSet(d, "//PCT-Request_reqid")[[1]]
xmlValue(n) <- reqid
return(d)
}
.get.assay.id.xml <- function(aid, id, type) {
if (type == 'cid')
d <- .load.pug.query("assay-cid.xml")
else if (type == 'sid')
d <- .load.pug.query("assay-sid.xml")
n <- getNodeSet(d, "//PCT-QueryAssayData_aids/PCT-QueryUids/PCT-QueryUids_ids/PCT-ID-List/PCT-ID-List_uids/PCT-ID-List_uids_E")[[1]]
xmlValue(n) <- aid
parent <- getNodeSet(d, "//PCT-QueryAssayData_scids/PCT-QueryUids/PCT-QueryUids_ids/PCT-ID-List/PCT-ID-List_uids")[[1]]
id <- unique(id)
sapply(id, function(x) {
n <- newXMLNode('PCT-ID-List_uids_E', x, parent=parent)
})
return(d)
}
.poll.pubchem <- function(reqid) {
root <- NA
pstring <- .xml2pugq(.get.poll.xml(reqid))
reqid <- NA
while(TRUE) {
h = basicTextGatherer()
curlPerform(url = 'http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi',
postfields = pstring,
writefunction = h$update)
## see if we got a waiting response
root <- xmlRoot(xmlTreeParse(h$value(), asText=TRUE, asTree=TRUE))
reqid <- xmlElementsByTagName(root, 'PCT-Waiting', recursive=TRUE)
if (length(reqid) != 0) next
break
}
return(root)
}
.read.url <- function(url) {
h = basicTextGatherer()
status = curlPerform(url = url,
writefunction = h$update)
val <- h$value()
if (str_detect(val, "Status: 404")) return(NULL)
return(val)
}
.ids.for.aid <- function(aid, type='cid', quiet=TRUE) {
if (!(type %in% c('cid', 'sid'))) stop("type must be 'cid' or 'sid'")
url <- sprintf('https://pubchem.ncbi.nlm.nih.gov/rest/pug/assay/aid/%d/%ss/TXT', aid, type)
if (!quiet) cat("URL:", url, "\n")
h = basicTextGatherer()
curlPerform(url = url,
writefunction = h$update)
cids <- as.integer(read.table(textConnection(h$value()), header=FALSE)[,1])
return(cids)
}
.section.by.heading <- function(seclist, heading) {
ret <- Filter(function(x) x$TOCHeading == heading, seclist)
if (length(ret) == 0) return(NULL)
return(ret[[1]])
}
.section.value <- function(seclist, heading) {
sec <- .section.by.heading(seclist, heading)
if (length(sec) == 0) return(NA)
return( sec[[1]]$Information[[1]]$NumValue )
}
.section.handler <- function(sec, keep = NULL, ignore = NULL) {
n <- sec$TOCHeading
if (!is.null(ignore) && n %in% ignore) return(NULL)
if (!is.null(keep) && !(n %in% keep)) return(NULL)
ret <- lapply(sec$Information, function(info) {
info.name <- info$Name
if (info.name == n) info.name <- ''
val <- NA
if ("NumValue" %in% names(info)) val <- as.numeric(info$NumValue)
else if ("StringValue" %in% names(info)) val <- info$StringValue
else if ("BinaryValue" %in% names(info)) val <- info$BinaryValue
ret <- data.frame(val=val)
if (info.name != '') {
names(ret) <- sprintf("%s.%s", n, info.name)
} else {
names(ret) <- n
}
return(ret)
})
return(ret)
}
.inchikey.2.cid <- function(key) {
url <- sprintf("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/inchikey/%s/cids/JSON", key)
page <- .read.url(url)
if (is.null(page)) return(NULL)
record <- fromJSON(content=page)
}
.cmpd.id2id <- function(id, src.type, dest.type, quiet=TRUE) {
entity <- switch(src.type,
inchikey = 'compound',
cid = 'compound',
name = 'compound',
inchi = 'compound',
sid = 'substance',
aid = 'assay')
if (is.null(entity)) {
warning("Invalid src.type specified")
return(NULL)
}
if (!(dest.type %in% c('sids', 'cids', 'aids'))) {
warning("Invalid dest.type specified")
return(NULL)
}
url <- sprintf("https://pubchem.ncbi.nlm.nih.gov/rest/pug/%s/%s/%s/%s/JSON",
entity, src.type, id, dest.type)
if (!quiet)
cat(url, '\n')
page <- .read.url(url)
if (is.null(page)) return(NULL)
record <- fromJSON(content=page)
if ('Fault' %in% names(record)) return(NULL)
else if ('IdentifierList' %in% names(record)) {
return(record$IdentifierList$CID[1])
} else if ('InformationList' %in% names(record)) {
info <- record$InformationList$Information[[1]]
if (dest.type == 'sids') ret <- info$SID
else if (dest.type == 'aids') ret <- info$AID
else if (dest.type == 'cids') ret <- info$CID
return(ret)
} else {
warning(sprintf("Unhandled response. Field names are: %s", paste0(names(record))))
return(NULL)
}
}
get.cid2 <- function(cid, quiet=TRUE) {
url <- sprintf('https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/data/compound/%d/JSON', cid)
page <- .read.url(url)
if (is.null(page)) {
warning(sprintf("No data found for %d", cid))
return(NULL)
}
record <- fromJSON(content=page)$Record
sections <- record$Section
## Identifiers
ids <- .section.by.heading(sections, "Names and Identifiers")
ids <- .section.by.heading(ids$Section, "Computed Descriptors")
ivals <- lapply(ids$Section, .section.handler)
ivals <- do.call(cbind, unlist(Filter(function(x) !is.null(x), ivals), recursive=FALSE))
## Process chemprops
props <- .section.by.heading(sections, "Chemical and Physical Properties")
if (is.null(props)) {
warning(sprintf("No phys/chem properties section for %d", cid))
return(NULL)
}
computed <- .section.by.heading(props$Section, "Computed Properties")
# cvals <- lapply(computed$Section, .section.handler,
#                 ignore= c(##"CACTVS Substructure Key Fingerprint",
#                   "Compound Is Canonicalized",
#                   "Covalently-Bonded Unit Count"))
# cvals <- do.call(cbind, unlist(Filter(function(x) !is.null(x), cvals), recursive=FALSE))
experimental <- .section.by.heading(props$Section, "Experimental Properties")
if (is.null(experimental)) {
evals <- data.frame(pKa=NA,"Kovats Retention Index"=NA)
} else {
evals <- lapply(experimental$Section, .section.handler,
keep = c('pKa', "Kovats Retention Index"))
evals <- unlist(Filter(function(x) !is.null(x), evals), recursive=FALSE)
if (is.null(evals))
evals <- data.frame(pKa=NA, "Kovats Retention Index"=NA)
else
evals <- do.call(cbind, evals)
}
return(data.frame(CID=cid, ivals, evals))
}
cids <- c(5282108, 5282148, 91754124)
dat <- lapply(cids, get.cid2)
.get.pug.url <- function() {
return("http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi")
}
.load.pug.query <- function(query.filename) {
path <- system.file('pugxml', query.filename, package='rpubchem')
doc <- xmlParse(path)
return(doc)
}
.xml2pugq <- function(xml) {
s <- saveXML(xml)
s <- gsub('<\\?xml version="1\\.0"\\?>', '', s)
s <- gsub("\\n", "", s)
return(s)
}
.get.poll.xml <- function(reqid) {
d <- .load.pug.query("pug-poll.xml")
n <- getNodeSet(d, "//PCT-Request_reqid")[[1]]
xmlValue(n) <- reqid
return(d)
}
.get.assay.id.xml <- function(aid, id, type) {
if (type == 'cid')
d <- .load.pug.query("assay-cid.xml")
else if (type == 'sid')
d <- .load.pug.query("assay-sid.xml")
n <- getNodeSet(d, "//PCT-QueryAssayData_aids/PCT-QueryUids/PCT-QueryUids_ids/PCT-ID-List/PCT-ID-List_uids/PCT-ID-List_uids_E")[[1]]
xmlValue(n) <- aid
parent <- getNodeSet(d, "//PCT-QueryAssayData_scids/PCT-QueryUids/PCT-QueryUids_ids/PCT-ID-List/PCT-ID-List_uids")[[1]]
id <- unique(id)
sapply(id, function(x) {
n <- newXMLNode('PCT-ID-List_uids_E', x, parent=parent)
})
return(d)
}
.poll.pubchem <- function(reqid) {
root <- NA
pstring <- .xml2pugq(.get.poll.xml(reqid))
reqid <- NA
while(TRUE) {
h = basicTextGatherer()
curlPerform(url = 'http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi',
postfields = pstring,
writefunction = h$update)
## see if we got a waiting response
root <- xmlRoot(xmlTreeParse(h$value(), asText=TRUE, asTree=TRUE))
reqid <- xmlElementsByTagName(root, 'PCT-Waiting', recursive=TRUE)
if (length(reqid) != 0) next
break
}
return(root)
}
.read.url <- function(url) {
h = basicTextGatherer()
status = curlPerform(url = url,
writefunction = h$update)
val <- h$value()
if (str_detect(val, "Status: 404")) return(NULL)
return(val)
}
.ids.for.aid <- function(aid, type='cid', quiet=TRUE) {
if (!(type %in% c('cid', 'sid'))) stop("type must be 'cid' or 'sid'")
url <- sprintf('https://pubchem.ncbi.nlm.nih.gov/rest/pug/assay/aid/%d/%ss/TXT', aid, type)
if (!quiet) cat("URL:", url, "\n")
h = basicTextGatherer()
curlPerform(url = url,
writefunction = h$update)
cids <- as.integer(read.table(textConnection(h$value()), header=FALSE)[,1])
return(cids)
}
.section.by.heading <- function(seclist, heading) {
ret <- Filter(function(x) x$TOCHeading == heading, seclist)
if (length(ret) == 0) return(NULL)
return(ret[[1]])
}
.section.value <- function(seclist, heading) {
sec <- .section.by.heading(seclist, heading)
if (length(sec) == 0) return(NA)
return( sec[[1]]$Information[[1]]$NumValue )
}
.section.handler <- function(sec, keep = NULL, ignore = NULL) {
n <- sec$TOCHeading
if (!is.null(ignore) && n %in% ignore) return(NULL)
if (!is.null(keep) && !(n %in% keep)) return(NULL)
ret <- lapply(sec$Information, function(info) {
info.name <- info$Name
if (info.name == n) info.name <- ''
val <- NA
if ("NumValue" %in% names(info)) val <- as.numeric(info$NumValue)
else if ("StringValue" %in% names(info)) val <- info$StringValue
else if ("BinaryValue" %in% names(info)) val <- info$BinaryValue
ret <- data.frame(val=val)
if (info.name != '') {
names(ret) <- sprintf("%s.%s", n, info.name)
} else {
names(ret) <- n
}
return(ret)
})
return(ret)
}
.inchikey.2.cid <- function(key) {
url <- sprintf("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/inchikey/%s/cids/JSON", key)
page <- .read.url(url)
if (is.null(page)) return(NULL)
record <- fromJSON(content=page)
}
.cmpd.id2id <- function(id, src.type, dest.type, quiet=TRUE) {
entity <- switch(src.type,
inchikey = 'compound',
cid = 'compound',
name = 'compound',
inchi = 'compound',
sid = 'substance',
aid = 'assay')
if (is.null(entity)) {
warning("Invalid src.type specified")
return(NULL)
}
if (!(dest.type %in% c('sids', 'cids', 'aids'))) {
warning("Invalid dest.type specified")
return(NULL)
}
url <- sprintf("https://pubchem.ncbi.nlm.nih.gov/rest/pug/%s/%s/%s/%s/JSON",
entity, src.type, id, dest.type)
if (!quiet)
cat(url, '\n')
page <- .read.url(url)
if (is.null(page)) return(NULL)
record <- fromJSON(content=page)
if ('Fault' %in% names(record)) return(NULL)
else if ('IdentifierList' %in% names(record)) {
return(record$IdentifierList$CID[1])
} else if ('InformationList' %in% names(record)) {
info <- record$InformationList$Information[[1]]
if (dest.type == 'sids') ret <- info$SID
else if (dest.type == 'aids') ret <- info$AID
else if (dest.type == 'cids') ret <- info$CID
return(ret)
} else {
warning(sprintf("Unhandled response. Field names are: %s", paste0(names(record))))
return(NULL)
}
}
get.cid2 <- function(cid, quiet=TRUE) {
url <- sprintf('https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/data/compound/%d/JSON', cid)
page <- .read.url(url)
if (is.null(page)) {
warning(sprintf("No data found for %d", cid))
return(NULL)
}
record <- fromJSON(content=page)$Record
sections <- record$Section
## Identifiers
ids <- .section.by.heading(sections, "Names and Identifiers")
ids <- .section.by.heading(ids$Section, "Computed Descriptors")
ivals <- lapply(ids$Section, .section.handler)
ivals <- do.call(cbind, unlist(Filter(function(x) !is.null(x), ivals), recursive=FALSE))
## Process chemprops
props <- .section.by.heading(sections, "Chemical and Physical Properties")
if (is.null(props)) {
warning(sprintf("No phys/chem properties section for %d", cid))
return(NULL)
}
computed <- .section.by.heading(props$Section, "Computed Properties")
# cvals <- lapply(computed$Section, .section.handler,
#                 ignore= c(##"CACTVS Substructure Key Fingerprint",
#                   "Compound Is Canonicalized",
#                   "Covalently-Bonded Unit Count"))
# cvals <- do.call(cbind, unlist(Filter(function(x) !is.null(x), cvals), recursive=FALSE))
experimental <- .section.by.heading(props$Section, "Experimental Properties")
if (is.null(experimental)) {
evals <- data.frame(pKa=NA,"Kovats Retention Index"=NA)
} else {
evals <- lapply(experimental$Section, .section.handler,
keep = c('pKa', "Kovats Retention Index"))
evals <- unlist(Filter(function(x) !is.null(x), evals), recursive=FALSE)
if (is.null(evals))
evals <- data.frame(pKa=NA, "Kovats Retention Index"=NA)
else
evals <- do.call(cbind, evals)
}
return(data.frame(CID=cid, ivals, evals))
}
cids <- c(145742)
dat <- lapply(cids, get.cid2)
library('ChemmineR')
sdfset <- read.SDFset("Chem_2D_FingerPrints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Chem_2D_Fingerrints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Chem_2D_Fingerprints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("/Chem_2D_Fingerprints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Chem_2D_Fingerprints\Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Chem_2D_Fingerprints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("\Chem_2D_Fingerprints\Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Chem_2D_Fingerprints\Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Chem_2D_Fingerprints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFset("Structure2D_CID_145742.sdf")
sdfset <- read.SDFset('Structure2D_CID_145742.sdf')
read.SDFset('C:\Users\ljd6ab\Documents\UVa_Work_for_New_Laptop\Papin_Lab\Biolog\Biolog_Replicates\biolog_data_complete\Cell_Systems\Supplement\gitClone\dunphy_yen_papin_supplement\S1B_Code\Chem_2D_Fingerprints\Structure2D_CID_145742.sdf')
sdfset <- read.SDFset("http://faculty.ucr.edu/~tgirke/Documents/R_BioCond/Samples/sdfsample.sdf")
sdfset <- read.SDFstr("Chem_2D_Fingerprints\Structure2D_CID_145742.sdf")
sdfset <- read.SDFstr("Chem_2D_Fingerprints/Structure2D_CID_145742.sdf")
sdfset <- read.SDFstr("/Chem_2D_Fingerprints/Structure2D_CID_145742.sdf")
